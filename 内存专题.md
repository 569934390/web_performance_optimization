###内存专题
----------
> - JavaScript 的内存回收机制
>
	以Google的V8引擎为例，在V8中，所有的JavaScript 对象都是通过『堆』来进行内存分配的。当我们在代码中声明变量并赋值时，V8 就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量时，V8 就会继续申请内存，直到堆的大小达到了V8 的内存上限为止。默认情况下，V8 的堆内存的大小上限在64位系统中为1464MB，在32位系统中则为732MB，即约1.4GB 和0.7GB。
>
	另外，V8 对堆内存中的JavaScript 对象进行分代管理：新生代和老生代。新生代即存活周期较短的JavaScript 对象，如临时变量、字符串等；而老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。
>	
	垃圾回收算法一直是编程语言的研发中是否重要的​​一环，而V8 中所使用的垃圾回收算法主要有以下几种：
	>
	Scavange 算法：通过复制的方式进行内存空间管理，主要用于新生代的内存空间；
	>
	Mark-Sweep 算法和Mark-Compact 算法：通过标记来对堆内存进行整理和回收，主要用于老生代对象的检查和回收。
>
	我们再来看看JavaScript 引擎在什么情况下会对哪些对象进行回收。
	>
	>1).作用域与引用
	>
	初学者常常会误认为当函数执行完毕时，在函数内部所声明的对象就会被销毁。但实际上这样理解并不严谨和全面，很容易被其导致混淆。
	>
	引用(Reference)是JavaScript 编程中十分重要的一个机制，但奇怪的是一般的开发者都不会刻意注意它、甚至不了解它。引用是指『代码对对象的访问』这一抽象关系，它与C/C++ 的指针有点相似，但并非同物。引用同时也是JavaScript 引擎在进行垃圾回收中最关键的一个机制。
	>
		var val = 'hello world';
		function foo() {
		  return function() {
		    return val;
		  };
		}
		global.bar = foo();
	>
	阅读完这段代码，你能否说出这部分代码在执行过后，有哪些对象是依然存活的么？
	>
	根据相关原则，这段代码中没有被回收释放的对象有val和bar()，究竟是什么原因使他们无法被回收？
	>
	JavaScript 引擎是如何进行垃圾回收的？前面说到的垃圾回收算法只是用在回收时的，那么它是如何知道哪些对象可以被回收，哪些对象需要继续生存呢？答案就是JavaScript 对象的引用。
	>
	JavaScript 代码中，哪怕是简单的写下一个变量名称作为单独一行而不做任何操作，JavaScript 引擎都会认为这是对对象的访问行为，存在了对对象的引用。为了保证垃圾回收的行为不影响程序逻辑的运行，JavaScript 引擎就决不能把正在使用的对象进行回收，不然就乱套了。所以判断对象是否正在使用中的标准，就是是否仍然存在对该对象的引用。但事实上，这是一种妥协的做法，因为JavaScript 的引用是可以进行转移的，那么就有可能出现某些引用被带到了全局作用域，但事实上在业务逻辑里已经不需要对其进行访问了，应该被回收，但是JavaScript 引擎仍会死板地认为程序仍然需要它。
	>
	如何用正确的姿势使用变量、引用，正是从语言层面优化JavaScript 的关键所在。
>
> - IE下闭包引起跨页面内存泄露	
> - JS的内存泄露处理
	- 给DOM对象添加的属性是一个对象的引用。范例：
		>
			var MyObject = {};
			document.getElementByIdx_x('myDiv').myProp = MyObject;
		>
		解决方法：在window.onunload事件中写上: 
		>
			document.getElementByIdx_x('myDiv').myProp = null;
		>
	- DOM对象与JS对象相互引用。范例：
		>
			function Encapsulator(element) {
			   this.elementReference = element;
			   element.myProp = this;
			}
			new Encapsulator(document.getElementByIdx_x('myDiv'));
		>
		解决方法：在onunload事件中写上: 
		>
			document.getElementByIdx_x('myDiv').myProp = null;
		>
	- 给DOM对象用attachEvent绑定事件。范例：
		>
			function doClick() {}
			element.attachEvent("onclick", doClick);
		>
		解决方法：在onunload事件中写上: 
		>
			element.detachEvent('onclick', doClick);
		>
	- 从外到内执行appendChild。这时即使调用removeChild也无法释放。范例：
		>
			var parentDiv =   document.createElement_x("div");
			var childDiv = document.createElement_x("div");
			document.body.appendChild(parentDiv);
			parentDiv.appendChild(childDiv);
		>
		解决方法：从内到外执行appendChild:
		>
			var parentDiv =   document.createElement_x("div");
			var childDiv = document.createElement_x("div");
			parentDiv.appendChild(childDiv);
			document.body.appendChild(parentDiv);
		>	 
	- 反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。范例：
		>
			for(i = 0; i < 5000; i++) {
			   hostElement.text = "asdfasdfasdf";
			}
		>
	这种方式相当于定义了5000个属性，解决方法：无。
>
> - 检查JavaScript 的内存使用情况
>
	在平时的开发中，我们也可以借助一些工具来对JavaScript 中内存使用情况进行分析和问题排查。
	>
	>1).Blink / Webkit 浏览器
	在Blink / Webkit 浏览器中（Chrome, Safari, Opera etc.），我们可以借助其中的Developer Tools 的Profiles 工具来对我们的程序进行内存检查。
	>
		Developer Tools - Profiles
	>
	>2).Node.js 中的内存检查
	>
	在Node.js 中，我们可以使用node-heapdump 和node-memwatch 模块进​​行内存检查。
	>
		var heapdump = require('heapdump');
		var fs = require('fs');
		var path = require('path');
		fs.writeFileSync(path.join(__dirname, 'app.pid'), process.pid);
	>
	在业务代码中引入node-heapdump 之后，我们需要在某个运行时期，向Node.js 进程发送SIGUSR2 信号，让node-heapdump 抓拍一份堆内存的快照。
	>
		$ kill -USR2 (cat app.pid)
	>
	这样在文件目录下会有一个以heapdump-<sec>.<usec>.heapsnapshot格式命名的快照文件，我们可以使用浏览器的Developer Tools中的Profiles工具将其打开，并进行检查。
> - 内存不是缓存
	- 缓存在业务开发中的作用举足轻重，可以减轻时空资源的负担。但需要注意的是，不要轻易将内存当作缓存使用。内存对于任何程序开发来说都是寸土寸金的东西，如果不是很重要的资源，请不要直接放在内存中，或者制定过期机制，自动销毁过期缓存。
> - CollectGarbage
	- 是IE的一个特有属性,用于释放内存的使用方法,将该变量或引用对象设置为null或delete然后在进行释放动作，在做CollectGarbage前,要必需清楚的两个必备条件:（引用）
		- 一个对象在其生存的上下文环境之外，即会失效。
		- 一个全局的对象在没有被执用(引用)的情况下，即会失效