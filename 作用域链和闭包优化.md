###作用域链和闭包优化
----------
> - 作用域：
	>作用域(scope)是JavaScript 编程中一个非常重要的运行机制，在同步JavaScript 编程中它并不能充分引起初学者的注意，但在异步编程中，良好的作用域控制技能成为了JavaScript 开发者的必备技能。另外，作用域在JavaScript 内存管理中起着至关重要的作用。
	>
	在JavaScript中，能形成作用域的有函数的调用、with语句和全局作用域。 如以下代码为例：
	>
		var foo = function() {
		  var local = {};
		};
		foo();
		console.log(local); //=> undefined
	>
		var bar = function() {
		  local = {};
		};
		bar();
		console.log(local); //=> {}
	>
	这里我们定义了foo()函数和bar()函数，他们的意图都是为了定义一个名为local的变量。但最终的结果却截然不同。
	>
	在foo()函数中，我们使用var语句来声明定义了一个local变量，而因为函数体内部会形成一个作用域，所以这个变量便被定义到该作用域中。而且foo()函数体内并没有做任何作用域延伸的处理，所以在该函数执行完毕后，这个local变量也随之被销毁。而在外层作用域中则无法访问到该变量。
	>
	而在bar()函数内，local变量并没有使用var语句进行声明，取而代之的是直接把local作为全局变量来定义。故外层作用域可以访问到这个变量。
	>
		local = {};
		// 这里的定义等效于
		global.local = {};
	>
	>2).作用域链
	>
	在JavaScript编程中，你一定会遇到多层函数嵌套的场景，这就是典型的作用域链的表示。 如以下代码所示：
	>
		function foo() {
		  var val = 'hello';
	>
		  function bar() {
		    function baz() {
		      global.val = 'world;'
		    }
		    baz();
		    console.log(val); //=> hello
		  }
		  bar();
		}
		foo();
	>
	根据前面关于作用域的阐述，你可能会认为这里的代码所显示的结果是world，但实际的结果却是hello。很多初学者在这里就会开始感到困惑了，那么我们再来看看这段代码是怎么工作的。
	>
	由于JavaScript 中，变量标识符的查找是从当前作用域开始向外查找，直到全局作用域为止。所以JavaScript 代码中对变量的访问只能向外进行，而不能逆而行之。
	>
	baz()函数的执行在全局作用域中定义了一个全局变量val。而在bar()函数中，对val这一标识符进行访问时，按照从内到外厄德查找原则：在bar函数的作用域中没有找到，便到上一层，即foo()函数的作用域中查找。
	>
	然而，使大家产生疑惑的关键就在这里：本次标识符访问在foo()函数的作用域中找到了符合的变量，便不会继续向外查找，故在baz()函数中定义的全局变量val并没有在本次变量访问中产生影响。
>
> - 减少作用域链上的查找次数
>
	js代码在执行的时候，如果需要访问一个变量或者一个函数的时候，它需要遍历当前执行环境的作用域链，而遍历是从这个作用域链的前端一级一级的向后遍历，直到全局执行环境，所以这里往往会出现一个情况，那就是如果我们需要经常访问全局环境的变量对象的时候，我们每次都必须在当前作用域链上一级一级的遍历，这显然是比较耗时的，我们看下面的例子：
>
	    /**效率低**/
		for(var i = 0; i < 10000; i++){
	        var but1 = document.getElementById("but1");
	    }
		/**效率高**/
	    var doc = document;
	    for(var i = 0; i < 10000; i++){
	        var but1 = doc.getElementById("but1");
	    }
>
	上面代码中，第二种情况是先把全局对象的变量放到函数里面先保存下来，然后直接访问这个变量，而第一种情况是每次都遍历作用域链，直到全局环境，我们看到第二种情况实际上只遍历了一次，而第一种情况却是每次都遍历了，而且这种差别在多级作用域链和多个全局变量的情况下还会表现的非常明显。
> -
> - 闭包
	我们知道JavaScript 中的标识符查找遵循从内到外的原则。但随着业务逻辑的复杂化，单一的传递顺序已经远远不能满足日益增多的新需求。
	>
	我们先来看看下面的代码：
	>
		function foo() {
		  var local = 'Hello';
		  return function() {
		    return local;
		  };
		}
		var bar = foo();
		console.log(bar()); //=> Hello
	>
	这里所展示的让外层作用域访问内层作用域的技术便是闭包(Closure)。得益于高阶函数的应用，使foo()函数的作用域得到『延伸』。
	>
	foo()函数返回了一个匿名函数，该函数存在于foo()函数的作用域内，所以可以访问到foo()函数作用域内的local变量，并保存其引用。而因这个函数直接返回了local变量，所以在外层作用域中便可直接执行bar()函数以获得local变量。
	>
	闭包是JavaScript 的高级特性，我们可以借助它来实现更多更复杂的效果来满足不同的需求。但是要注意的是因为把带有​​内部变量引用的函数带出了函数外部，所以该作用域内的变量在函数执行完毕后的并不一定会被销毁，直到内部变量的引用被全部解除。所以闭包的应用很容易造成内存无法释放的情况。
>
> - 良好的闭包管理
	>
	当我们的业务需求(如循环事件绑定、私有属性、含参回调等)一定要使用闭包时，请谨慎对待其中的细节。
	>
	循环绑定事件可谓是JavaScript 闭包入门的必修课，我们假设一个场景：有六个按钮，分别对应六种事件，当用户点击按钮时，在指定的地方输出相应的事件。
	>
	var btns = document.querySelectorAll('.btn'); // 6 elements
	var output = document.querySelector('#output');
	var events = [1, 2, 3, 4, 5, 6];
	>
		// Case 1
		for (var i = 0; i < btns.length; i++) {
		  btns[i].onclick = function(evt) {
		    output.innerText += 'Clicked ' + events[i];
		  };
		}
	>
		// Case 2
		for (var i = 0; i < btns.length; i++) {
		  btns[i].onclick = (function(index) {
		    return function(evt) {
		      output.innerText += 'Clicked ' + events[index];
		    };
		  })(i);
		}
	>
		// Case 3
		for (var i = 0; i < btns.length; i++) {
		  btns[i].onclick = (function(event) {
		    return function(evt) {
		      output.innerText += 'Clicked ' + event;
		    };
		  })(events[i]);
		}
	>
	这里第一个解决方案显然是典型的循环绑定事件错误，这里不细说，详细可以参照我给一个网友的回答；而第二和第三个方案的区别就在于闭包传入的参数。
	>
	第二个方案传入的参数是当前循环下标，而后者是直接传入相应的事件对象。事实上，后者更适合在大量数据应用的时候，因为在JavaScript的函数式编程中，函数调用时传入的参数是基本类型对象，那么在函数体内得到的形参会是一个复制值，这样这个值就被当作一个局部变量定义在函数体的作用域内，在完成事件绑定之后就可以对events变量进行手工解除引用，以减轻外层作用域中的内存占用了。而且当某个元素被删除时，相应的事件监听函数、事件对象、闭包函数也随之被销毁回收。
> - 作用域。
>
	随着作用域数量的增加，访问当前作用域以外的变量的时间也在增加。所以，访问全局变量总是比访问局部变量要慢，因为需要遍历作用域链。只要能减少花费在作用域链上的时间，就能增加脚本的整体性能。
>
		/**避免全局查找**/
		function findImgTitle() {
		    var imgs = document.getElementByTagName("img");
		    for(var i = 0, len = imgs.length; i < len; i++) {
		        imgs[i].title = document.title + " image " + i;
		    }
		}
>
	函数findImgTitle中包含了两个对于全局变量document对象的引用，即`document.getElementByTagName`和`document.title`，而且循环中的`document.title`引用，在作用域链查找的次数是`O(n)`。通过创建一个指向`document`的局部变量，就可以通过限制一次全局查找来改进这个函数的性能。
>
		/**避免全局查找**/
		function findImgTitle() {
		    var doc = document;
		    var imgs = doc.getElementByTagName("img");
		    for(var i = 0, len = imgs.length; i < len; i++) {
		        imgs[i].title = doc.title + " image " + i;
		    }
		}
>
	其次还有避免`with`语句，`with`会创建自已的作用域，因此会增加其中执行代码的作用域的长度。
> - 避开闭包陷阱
	- 闭包是个强大的工具，但同时也是性能问题的主要诱因之一。不合理的使用闭包会导致内存泄漏。
	- 闭包的性能不如使用内部方法，更不如重用外部方法。
>
		由于IE浏览器的DOM是用COM来实现的， COM的内存管理是通过引用计数的方式，引用计数有个难题就是循环引用，一旦DOM 引用了闭包(例如event handler)，闭包的上层元素又引用了这个DOM，就会造成循环引用从而导致内存泄漏。
> - 闭包尽管强大，但不可滥用，否则会影响到执行速度以及内存
> - 善用函数
	如果你有阅读优秀JavaScript 项目的习惯的话，你会发现，很多大牛在开发前端JavaScript 代码的时候，常常会使用一个匿名函数在代码的最外层进行包裹。
	>
		;(function() {
		  // 主业务代码
		})();
	>
	有的甚至更高级一点：
	>
		;(function(win, doc, $, undefined) {
		  // 主业务代码
		})(window, document, jQuery);
	>
	甚至连如RequireJS, SeaJS, OzJS 等前端模块化加载解决方案，都是采用类似的形式：
	>
		// RequireJS
		define(['jquery'], function($) {
		  // 主业务代码
		});
	>
		// SeaJS
		define('m​​odule', ['dep', 'underscore'], function($, _) {
		  // 主业务代码
		});
	>
	如果你说很多Node.js 开源项目的代码都没有这样处理的话，那你就错了。Node.js 在实际运行代码之前，会把每一个.js 文件进行包装，变成如下的形式：
	>
		(function(exports, require, module, __dirname, __filename) {
		  // 主业务代码
		});
	>
	这样做有什么好处？我们都知道文章开始的时候就说了，JavaScript中能形成作用域的有函数的调用、with语句和全局作用域。而我们也知道，被定义在全局作用域的对象，很有可能是会一直存活到进程退出的，如果是一个很大的对象，那就麻烦了。比如有的人喜欢在JavaScript中做模版渲染：
	>
		<?php
		  $db = mysqli_connect(server, user, password, 'myapp');
		  $topics = mysqli_query($db, "SELECT * FROM topics;");
		?>
		<!doctype html>
		<html lang="en">
		<head>
		  <meta charset="UTF-8">
		  <title>你是猴子请来的逗比么？</title>
		</head>
		<body>
		  <ul id="topics"></ul>
		  <script type="text/tmpl" id="topic-tmpl">
		    <li class="topic">
		      <h1><%=title%></h1>
		      <p><%=content%></p>
		    </li>
		  </script>
		  <script type="text/javascript">
		    var data = <?php echo json_encode($topics); ?>;
		    var topicTmpl = document.querySelector('#topic-tmpl').innerHTML;
		    var render = function(tmlp, view) {
		      var complied = tmlp
		        .replace(/\n/g, '\\n')
		        .replace(/<%=([\s\S]+?)%>/g, function(match, code) {
		          return '" + escape(' + code + ') + "';
		        });
	>
		      complied = [
		        'var res = "";',
		        'with (view || {}) {',
		          'res = "' + complied + '";',
		        '}',
		        'return res;'
		      ].join('\n');
	>
		      var fn = new Function('view', complied);
		      return fn(view);
		    };
	>
		    var topics = document.querySelector('#topics');
		    function init()
		      data.forEach(function(topic) {
		        topics.innerHTML += render(topicTmpl, topic);
		      });
		    }
		    init();
		  </script>
		</body>
		</html>
	>
	这种代码在新手的作品中经常能看得到，这里存在什么问题呢？如果在从数据库中获取到的数据的量是非常大的话，前端完成模板渲染以后，data变量便被闲置在一边。可因为这个变量是被定义在全局作用域中的，所以JavaScript引擎不会将其回收销毁。如此该变量就会一直存在于老生代堆内存中，直到页面被关闭。
	>
	可是如果我们作出一些很简单的修改，在逻辑代码外包装一层函数，这样效果就大不同了。当UI渲染完成之后，代码对data的引用也就随之解除，而在最外层函数执行完毕时，JavaScript引擎就开始对其中的对象进行检查，data也就可以随之被回收。
